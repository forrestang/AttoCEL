<!-- PART 4: LIGHTWEIGHT CHARTS 5.0.8 INTEGRATION -->
<!-- This code handles chart display and trade visualization using the latest v5.0.8 API -->

<!-- Add Lightweight Charts 5.0.8 CDN -->
<script src="https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.production.js"></script>

<script>
// Part 4: Charts Integration with Lightweight Charts v5.0.8

let chart = null;
let candlestickSeries = null;
let volumeSeries = null;
let tradeMarkers = [];
let sessionBoxes = [];

// Chart configuration
const chartConfig = {
    width: 0, // Will be set dynamically
    height: 350,
    layout: {
        background: { color: '#0d1117' },
        textColor: '#e6edf3',
    },
    grid: {
        vertLines: { color: '#30363d' },
        horzLines: { color: '#30363d' },
    },
    crosshair: {
        mode: LightweightCharts.CrosshairMode.Normal,
    },
    rightPriceScale: {
        borderColor: '#30363d',
        textColor: '#e6edf3',
    },
    timeScale: {
        borderColor: '#30363d',
        textColor: '#e6edf3',
        timeVisible: true,
        secondsVisible: false,
    },
    watermark: {
        visible: true,
        fontSize: 48,
        horzAlign: 'center',
        vertAlign: 'center',
        color: 'rgba(255, 255, 255, 0.05)',
        text: 'ORB Dashboard',
    },
};

// Initialize chart
function initializeChart() {
    const chartContainer = document.getElementById('chart-placeholder');
    if (!chartContainer) {
        console.error('Chart container not found');
        return;
    }

    // Clear existing chart
    if (chart) {
        chart.remove();
        chart = null;
    }

    // Set chart width to container width
    chartConfig.width = chartContainer.offsetWidth;
    chartConfig.height = chartContainer.offsetHeight;

    try {
        // Create chart using v5.0.8 API
        chart = LightweightCharts.createChart(chartContainer, chartConfig);

        // Add candlestick series using new v5 API
        candlestickSeries = chart.addCandlestickSeries({
            upColor: '#56d364',
            downColor: '#f85149',
            borderUpColor: '#56d364',
            borderDownColor: '#f85149',
            wickUpColor: '#56d364',
            wickDownColor: '#f85149',
            priceFormat: {
                type: 'price',
                precision: 2,
                minMove: 0.01,
            },
        });

        // Add volume series
        volumeSeries = chart.addHistogramSeries({
            color: '#26a0fc',
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: 'volume',
            scaleMargins: {
                top: 0.8,
                bottom: 0,
            },
        });

        // Store chart reference globally
        window.dashboardState.chart = chart;

        console.log('Chart initialized successfully with Lightweight Charts v5.0.8');
        
        // Load data if available
        if (window.dashboardState.chartData) {
            loadChartData(window.dashboardState.chartData);
        }

    } catch (error) {
        console.error('Failed to initialize chart:', error);
        chartContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #f85149;">
                <div>
                    <div>Chart initialization failed</div>
                    <div style="font-size: 12px; margin-top: 5px;">${error.message}</div>
                </div>
            </div>
        `;
    }
}

// Load chart data using v5.0.8 API
function loadChartData(data) {
    if (!chart || !candlestickSeries || !data || data.length === 0) {
        console.warn('Chart or data not ready');
        return;
    }

    try {
        // Prepare candlestick data using v5 format
        const candleData = data.map(candle => ({
            time: candle.time, // Already converted to seconds in Part 3
            open: candle.open,
            high: candle.high,
            low: candle.low,
            close: candle.close
        }));

        // Prepare volume data
        const volumeData = data.map(candle => ({
            time: candle.time,
            value: candle.volume,
            color: candle.close >= candle.open ? '#56d36440' : '#f8514940'
        }));

        // Set data using v5.0.8 API
        candlestickSeries.setData(candleData);
        volumeSeries.setData(volumeData);

        // Auto-fit content
        chart.timeScale().fitContent();

        console.log(`Chart loaded with ${candleData.length} candles`);

        // Update chart placeholder text
        const chartContainer = document.getElementById('chart-placeholder');
        if (chartContainer) {
            // Remove placeholder text since chart is now loaded
            const placeholder = chartContainer.querySelector('.chart-placeholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
        }

    } catch (error) {
        console.error('Failed to load chart data:', error);
    }
}

// Add trade markers to the chart
function addTradeMarkers(trades) {
    if (!chart || !candlestickSeries || !trades || trades.length === 0) {
        return;
    }

    try {
        // Clear existing markers
        clearTradeMarkers();

        // Prepare markers for v5.0.8
        const markers = trades.map(trade => {
            const isLong = trade.side === 'LONG';
            const isEntry = trade.type === 'entry';
            
            let color = isLong ? '#56d364' : '#f85149';
            let shape = isEntry ? 'arrowUp' : 'arrowDown';
            let position = isEntry ? 'belowBar' : 'aboveBar';

            // Different shapes for entry vs exit
            if (!isEntry) {
                shape = isLong ? 'arrowDown' : 'arrowUp';
                position = isLong ? 'aboveBar' : 'belowBar';
                color = trade.pnl >= 0 ? '#56d364' : '#f85149';
            }

            return {
                time: trade.time,
                position: position,
                color: color,
                shape: shape,
                text: `${trade.side} ${trade.type.toUpperCase()}\n${trade.price}\n${trade.pnl ? `${trade.pnl.toFixed(2)}R` : ''}`,
                size: 1,
            };
        });

        // Add markers using v5.0.8 API
        candlestickSeries.setMarkers(markers);
        tradeMarkers = markers;

        console.log(`Added ${markers.length} trade markers to chart`);

    } catch (error) {
        console.error('Failed to add trade markers:', error);
    }
}

// Add session boxes to show opening ranges
function addSessionBoxes(sessions) {
    if (!chart || !sessions || sessions.length === 0) {
        return;
    }

    try {
        // Clear existing session boxes
        clearSessionBoxes();

        sessions.forEach((session, index) => {
            if (session.openingRange) {
                // Create opening range rectangle
                const rectangle = {
                    time1: session.openingRange.startTime,
                    time2: session.openingRange.endTime,
                    price1: session.openingRange.high,
                    price2: session.openingRange.low,
                };

                // Add rectangle using v5 drawing primitives
                const rect = candlestickSeries.createPriceLine({
                    price: session.openingRange.high,
                    color: '#58a6ff',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: false,
                    title: `OR High S${index + 1}`,
                });

                const rectLow = candlestickSeries.createPriceLine({
                    price: session.openingRange.low,
                    color: '#58a6ff',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: false,
                    title: `OR Low S${index + 1}`,
                });

                sessionBoxes.push(rect, rectLow);
            }
        });

        console.log(`Added ${sessionBoxes.length / 2} session opening ranges to chart`);

    } catch (error) {
        console.error('Failed to add session boxes:', error);
    }
}

// Clear trade markers
function clearTradeMarkers() {
    if (candlestickSeries && tradeMarkers.length > 0) {
        candlestickSeries.setMarkers([]);
        tradeMarkers = [];
    }
}

// Clear session boxes
function clearSessionBoxes() {
    sessionBoxes.forEach(box => {
        if (box && typeof box.remove === 'function') {
            box.remove();
        }
    });
    sessionBoxes = [];
}

// Update chart with backtest results
function updateChartWithResults(backtestResults) {
    if (!backtestResults) {
        console.warn('No backtest results to display');
        return;
    }

    try {
        // Add trade markers
        if (backtestResults.trades) {
            addTradeMarkers(backtestResults.trades);
        }

        // Add session boxes
        if (backtestResults.sessions) {
            addSessionBoxes(backtestResults.sessions);
        }

        // Fit content to show all data
        if (chart) {
            chart.timeScale().fitContent();
        }

    } catch (error) {
        console.error('Failed to update chart with results:', error);
    }
}

// Resize chart when container size changes
function resizeChart() {
    if (chart) {
        const chartContainer = document.getElementById('chart-placeholder');
        if (chartContainer) {
            chart.applyOptions({
                width: chartContainer.offsetWidth,
                height: chartContainer.offsetHeight,
            });
        }
    }
}

// Chart data conversion utilities
function convertDataForChart(rawData) {
    if (!rawData || !Array.isArray(rawData)) {
        return [];
    }

    return rawData.map(item => ({
        time: item.time || Math.floor(item.timestamp / 1000),
        open: parseFloat(item.open),
        high: parseFloat(item.high),
        low: parseFloat(item.low),
        close: parseFloat(item.close),
        volume: parseFloat(item.volume || 0)
    })).sort((a, b) => a.time - b.time);
}

// Get chart time range
function getChartTimeRange() {
    if (!chart) {
        return null;
    }

    try {
        const timeScale = chart.timeScale();
        const visibleRange = timeScale.getVisibleRange();
        
        return {
            from: visibleRange.from,
            to: visibleRange.to
        };
    } catch (error) {
        console.error('Failed to get chart time range:', error);
        return null;
    }
}

// Set chart time range
function setChartTimeRange(from, to) {
    if (!chart) {
        return;
    }

    try {
        chart.timeScale().setVisibleRange({ from, to });
    } catch (error) {
        console.error('Failed to set chart time range:', error);
    }
}

// Export chart as image
function exportChartImage() {
    if (!chart) {
        alert('No chart to export');
        return;
    }

    try {
        chart.takeScreenshot().then(canvas => {
            const link = document.createElement('a');
            link.download = `chart_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });
    } catch (error) {
        console.error('Failed to export chart:', error);
        alert('Chart export failed');
    }
}

// Chart event handlers
function setupChartEventHandlers() {
    if (!chart) {
        return;
    }

    // Click handler for trade details
    chart.subscribeClick((param) => {
        if (param.time) {
            const trades = tradeMarkers.filter(marker => marker.time === param.time);
            if (trades.length > 0) {
                console.log('Trade clicked:', trades[0]);
                // Could show trade details popup here
            }
        }
    });

    // Crosshair move handler
    chart.subscribeCrosshairMove((param) => {
        if (param.time) {
            // Could show price/time info here
        }
    });
}

// Initialize chart theme
function setChartTheme(theme = 'dark') {
    if (!chart) {
        return;
    }

    const themes = {
        dark: {
            layout: {
                background: { color: '#0d1117' },
                textColor: '#e6edf3',
            },
            grid: {
                vertLines: { color: '#30363d' },
                horzLines: { color: '#30363d' },
            },
        },
        light: {
            layout: {
                background: { color: '#ffffff' },
                textColor: '#000000',
            },
            grid: {
                vertLines: { color: '#e1e4e8' },
                horzLines: { color: '#e1e4e8' },
            },
        }
    };

    chart.applyOptions(themes[theme] || themes.dark);
}

// Export functions for use by other parts
window.dashboardChart = {
    initializeChart,
    loadChartData,
    addTradeMarkers,
    addSessionBoxes,
    updateChartWithResults,
    clearTradeMarkers,
    clearSessionBoxes,
    resizeChart,
    exportChartImage,
    getChartTimeRange,
    setChartTimeRange,
    setChartTheme,
    convertDataForChart
};

// Initialize Part 4 when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('Part 4: Lightweight Charts 5.0.8 integration loaded');
    
    // Initialize chart after a small delay to ensure container is ready
    setTimeout(() => {
        initializeChart();
        setupChartEventHandlers();
    }, 100);
});

// Handle window resize
window.addEventListener('resize', () => {
    setTimeout(resizeChart, 100);
});

// Auto-load chart data when it becomes available
document.addEventListener('dataLoaded', function(event) {
    if (event.detail && event.detail.chartData) {
        loadChartData(event.detail.chartData);
    }
});

// Auto-update chart when backtest completes
document.addEventListener('backtestComplete', function(event) {
    if (event.detail && event.detail.results) {
        updateChartWithResults(event.detail.results);
    }
});

console.log('Part 4: Lightweight Charts 5.0.8 script loaded');
</script>

<style>
/* Chart container specific styles */
#chart-placeholder {
    position: relative;
    background: #0d1117;
    border-radius: 6px;
    border: 1px solid #30363d;
    overflow: hidden;
}

/* Hide placeholder text when chart is loaded */
#chart-placeholder .chart-placeholder {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #8b949e;
    font-size: 16px;
    z-index: 1;
    pointer-events: none;
}

/* Chart controls overlay */
.chart-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
    display: flex;
    gap: 5px;
}

.chart-control-btn {
    background: rgba(22, 27, 34, 0.8);
    border: 1px solid #30363d;
    color: #e6edf3;
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(8px);
}

.chart-control-btn:hover {
    background: rgba(48, 54, 61, 0.8);
}

/* Loading overlay */
.chart-loading {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(13, 17, 23, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 20;
    backdrop-filter: blur(4px);
}

.chart-loading.hidden {
    display: none;
}
</style>

<!-- INTEGRATION INSTRUCTIONS FOR FINAL ASSEMBLY:
1. Add the Lightweight Charts 5.0.8 CDN script tag to the head section
2. Add this JavaScript to the main script section in Part 1
3. Add the CSS styles to the main style section in Part 1
4. The chart will automatically initialize when the DOM is ready
5. Chart functions are available via window.dashboardChart object
6. Chart will auto-load data when available and update with backtest results
-->